<head>
    <style>

        .node circle {
            fill: #fff;
            stroke: steelblue;
            stroke-width: 1.5px;
        }

        .node {
            font: 12px sans-serif;
        }

        .node.review { fill: #33CC00; }
        .node.defined { fill: #CC00FF; }
        .node.in-progress { fill: #6600CC; }
        .node.completed { fill: #0033CC; }
        .node.accepted { fill: #FF9999; }
        .node.ready { fill: #CC0000; }

        .link {
            fill: none;
            stroke: #ccc;
            stroke-width: 1.5px;
        }

        div.tooltip {   
          position: absolute;           
          text-align: left;
          width: 300px;                      
          padding: 2px;             
          font: 12px sans-serif;        
          background: lightsteelblue;   
          border: 0px;      
          border-radius: 8px;           
          pointer-events: none;         
        }

      .context-menu {
        -webkit-border-radius: 5px;
        -moz-border-radius: 5px;
        border-radius: 5px;

        background-color: #f2f2f2;
        border: 1px solid #999;

        list-style-type: none;
        margin: 0;
        padding: 0;
      }
      .context-menu a {
        display: block;
        padding: 3px;
        text-decoration: none;
        color: #333;
      }
      .context-menu a:hover {
        background-color: #666;
        color: white;
      }

    </style>
    <script type="text/javascript" src="https://rally1.rallydev.com/apps/2.0p5/sdk-debug.js"></script>
    <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.1/jquery.min.js" type="text/javascript"></script>
    <script>
        /*
         * jQuery.contextMenu - Show a custom context when right clicking something
         * Jonas Arnklint, http://github.com/arnklint/jquery-contextMenu
         * Released into the public domain
         * Date: Jan 14, 2011
         * @author Jonas Arnklint
         * @version 1.7
         *
        */
        // Making a local '$' alias of jQuery to support jQuery.noConflict
        (function($) {
          jQuery.fn.contextMenu = function ( name, actions, options ) {
            var me = this,
            win = $(window),
            menu = $('<ul id="'+name+'" class="context-menu"></ul>').hide().appendTo('body'),
            activeElement = null, // last clicked element that responds with contextMenu
            hideMenu = function() {
              $('.context-menu:visible').each(function() {
                $(this).trigger("closed");
                $(this).hide();
                $('body').unbind('click', hideMenu);
                menu.unbind('closed');
              });
            },
            default_options = {
              disable_native_context_menu: false, // disables the native contextmenu everywhere you click
              leftClick: false // show menu on left mouse click instead of right
            },
            options = $.extend(default_options, options);

            $(document).bind('contextmenu', function(e) {
              if (options.disable_native_context_menu) {
                e.preventDefault();
              }
              hideMenu();
            });

            $.each(actions, function(me, itemOptions) {
              if (itemOptions.link) {
                var link = itemOptions.link;
              } else {
                var link = '<a href="#">'+me+'</a>';
              }

              var menuItem = $('<li>' + link + '</li>');

              if (itemOptions.klass) {
                menuItem.attr("class", itemOptions.klass);
              }

              menuItem.appendTo(menu).bind('click', function(e) {
                itemOptions.click(activeElement);
                e.preventDefault();
              });
            });

            if (options.leftClick) {
              var mouseEvent = 'click';
            } else {
              var mouseEvent = 'contextmenu';
            }

            var mouseEventFunc = function(e){
              // Hide any existing context menus
              hideMenu();

              activeElement = $(this); // set clicked element

              if (options.showMenu) {
                options.showMenu.call(menu, activeElement);
              }

              // Bind to the closed event if there is a hideMenu handler specified
              if (options.hideMenu) {
                menu.bind("closed", function() {
                  options.hideMenu.call(menu, activeElement);
                });
              }

              menu.css({
                visibility: 'hidden',
                position: 'absolute',
                zIndex: 1000
              });

              // include margin so it can be used to offset from page border.
              var mWidth = menu.outerWidth(true),
                mHeight = menu.outerHeight(true),
                xPos = ((e.pageX - win.scrollLeft()) + mWidth < win.width()) ? e.pageX : e.pageX - mWidth,
                yPos = ((e.pageY - win.scrollTop()) + mHeight < win.height()) ? e.pageY : e.pageY - mHeight;

              menu.show(0, function() {
                $('body').bind('click', hideMenu);
              }).css({
                visibility: 'visible',
                top: yPos + 'px',
                left: xPos + 'px',
                zIndex: 1000
              });

              return false;
            }

            if (options.delegateEventTo) {
              return me.on(mouseEvent, options.delegateEventTo, mouseEventFunc)
            } else {
              return me.bind(mouseEvent, mouseEventFunc);
            }
          }
        })(jQuery);
    </script>
</head>
<body>
    <button onclick="toggle()" style="position:fixed;top:20;left:25">Toggle!</button>
    <script>
        // Credit for convert to Arun P Johny, http://stackoverflow.com/questions/15376251/hierarchical-json-from-flat-with-parent-id-using-javascript
        function convert(array) {
            var map = {};

            for (var i = 0; i < array.length; i++) {
                var obj = array[i];

                map[obj.FormattedID] = obj;

                var parent = obj.ParentID || '-';
                if (!map[parent]) {
                    map[parent] = {};
                }

                if( map[parent].children === undefined ) map[parent].children = [];
                map[parent].children.push(obj);
            }

            return { name: "D2L", children: map['-'].children };

        }

        var treeToggle = false;
        var toggle = function() {}

        Rally.onReady(function () {
            Ext.application({
                name: 'MyApp',
                launch: function () {

                    var storyArray = [];

                    Ext.create('Rally.data.WsapiDataStore', {
                        model: 'UserStory',
                        autoLoad: true,
                        limit: Infinity,
                        fetch: ['Name', 'FormattedID', 'Description', 'Parent', 'ScheduleState', 'ObjectID', 'Owner'],
                        listeners: {
                            load: function (store, stories) {

                                var div = d3.select("body").append("div")
                                    .attr("class", "tooltip")
                                    .style("opacity", 0);

                                var maxLength = 0; // Length of longest story name (after truncation)
                                var truncateLength = 80; // truncates story names to this number of characters
                                var marginPerCharacter = 5.5; // used to scale the margin in proportion to the number of characters in the name
                                var heightPerStory = 20;

                                Ext.Array.each(stories, function (story) {

                                    var truncatedName = story.get('Name').substring(0, truncateLength);

                                    if (truncatedName.length == truncateLength) { truncatedName += "..."; }

                                    if (story.get('Parent') !== null && story.get('Parent') !== undefined) {
                                        storyArray.push({ name: truncatedName, FormattedID: story.get('FormattedID'), Description: story.get('Description'), ScheduleState: story.get('ScheduleState'), ObjectID: story.get('ObjectID'), Owner: story.get('Owner'), ParentID: story.get('Parent').FormattedID });
                                    }
                                    else {
                                        storyArray.push({ name: truncatedName, FormattedID: story.get('FormattedID'), Description: story.get('Description'), ScheduleState: story.get('ScheduleState'), ObjectID: story.get('ObjectID'), Owner: story.get('Owner') });
                                    }

                                    if (truncatedName.length > maxLength) {
                                        maxLength = truncatedName.length;
                                    }
                                });

                                function decode(str) {
                                    return $("<div/>").html(str).text();
                                }

                                $.each(storyArray, function (i, s) {
                                    s.name = decode(s.name);
                                    s.Description = decode(s.Description);
                                });

                                var numStories = storyArray.length;
                                var convertedStoryArray = convert(storyArray);

                                var margin = { top: 20, right: marginPerCharacter * maxLength, bottom: 20, left: 120 },
                                height = (storyArray.length * heightPerStory) - margin.top - margin.bottom;

                                var i = 0,
                                duration = 500,
                                root;

                                root = convertedStoryArray;
                                root.x0 = height / 2;
                                root.y0 = 0;

                                toggle = function () {
                                    treeToggle = !treeToggle;
                                    update(root);    
                                }

                                var tree = d3.layout.cluster();

                                var maxDepth = 0;
                                tree.nodes(root).forEach(function(d) {
                                    if( d.depth > maxDepth ) {
                                        maxDepth = d.depth;
                                    }
                                });

                                var width = ( 180 * ( maxDepth + 3 ) ) - margin.right - margin.left;

                                tree.size([height, width]);

                                var diagonal = d3.svg.diagonal()
                                .projection(function (d) { return [d.y, d.x]; });

                                var svg = d3.select("body").append("svg")
                                .attr("width", width + margin.right + margin.left)
                                .attr("height", height + margin.top + margin.bottom)
                                .append("g")
                                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

                                function collapse(d) {
                                    if (d.children) {
                                        d._children = d.children;
                                        d._children.forEach(collapse);
                                        d.children = null;
                                    }
                                }

                                update(root);

                                //d3.select(self.frameElement).style("height", "800px");

                                function update(source) {


                                    // Compute the new tree layout.
                                    var nodes = tree.nodes(root).reverse(),
                                    links = tree.links(nodes);

                                    // Position for nodes based on depth
                                    nodes.forEach(function(d) {
                                        if( treeToggle || d.children ) {
                                            d.y = d.depth * 180;
                                        } else {
                                            d.y = maxDepth * 180;
                                        }
                                    });

                                    // Update the nodes
                                    var node = svg.selectAll("g.node")
                                    .data(nodes, function (d) { return d.id || (d.id = ++i); });

                                    // Enter any new nodes at the parent's previous position.
                                    var nodeEnter = node.enter().append("g")
                                    .attr("class", function (d) {
                                        var classString = "node";
                                        switch (d.ScheduleState) {
                                            case "In Review":
                                                classString += " review";
                                                break;
                                            case "Defined":
                                                classString += " defined";
                                                break;
                                            case "In-Progress":
                                                classString += " in-progress";
                                                break;
                                            case "Completed":
                                                classString += " completed";
                                                break;
                                            case "Accepted":
                                                classString += " accepted";
                                                break;
                                            case "Ready for Release":
                                                classString += " ready";
                                                break;
                                            default: break;
                                        }
                                        return classString;
                                    })
                                    .attr("transform", function (d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
                                    .on("click", click)
                                    .on("contextmenu", rclick)
                                    .on("mouseover", function (d) {

                                        var content = "";

                                        if ( !d.Owner && !d.Description ) return; 

                                        content = "<b>Owner:</b> ";
                                        content += d.Owner ? d.Owner._refObjectName : "(None)";
                                        
                                        if (d.Description) {
                                            content += "<br><br><b>Description:</b>: " + d.Description;
                                        }
                                        
                                        div.transition()
                                            .duration(200)
                                            .style("opacity", .9);
                                        div.html(content)
                                            .style("left", (d3.event.pageX) + "px")
                                            .style("top", (d3.event.pageY - 28) + "px");
                                    })
                                    .on("mouseout", function (d) {
                                        div.transition()
                                            .duration(500)
                                            .style("opacity", 0);
                                    });

                                    nodeEnter.append("circle")
                                    .attr("r", 1e-6)
                                    .style("fill", function (d) { return d._children ? "lightsteelblue" : "#fff"; });

                                    nodeEnter.append("text")
                                    .attr("x", function (d) { return d.children || d._children ? -10 : 10; })
                                    .attr("dy", ".35em")
                                    .attr("text-anchor", function (d) { return d.children || d._children ? "end" : "start"; })
                                    .text(function (d) { return d.name; })
                                    .style("fill-opacity", 1e-6);

                                    // Transition nodes to their new position.
                                    var nodeUpdate = node.transition()
                                    .duration(duration)
                                    .attr("transform", function (d) { return "translate(" + d.y + "," + d.x + ")"; });

                                    nodeUpdate.select("circle")
                                    .attr("r", 4.5)
                                    .style("fill", function (d) { return d._children ? "lightsteelblue" : "#fff"; });

                                    nodeUpdate.select("text")
                                    .attr("x", function (d) { return d.children ? -10 : 10; })
                                    .attr("text-anchor", function (d) { return d.children ? "end" : "start"; })
                                    .style("fill-opacity", 1);

                                    // Transition exiting nodes to the parent's new position.
                                    var nodeExit = node.exit().transition()
                                    .duration(duration)
                                    .attr("transform", function (d) { return "translate(" + source.y + "," + source.x + ")"; })
                                    .remove();

                                    nodeExit.select("circle")
                                    .attr("r", 1e-6);

                                    nodeExit.select("text")
                                    .style("fill-opacity", 1e-6);

                                    // Update the links
                                    var link = svg.selectAll("path.link")
                                    .data(links, function (d) { return d.target.id; });

                                    // Enter any new links at the parent's previous position.
                                    link.enter().insert("path", "g")
                                    .attr("class", "link")
                                    .attr("d", function (d) {
                                        var o = { x: source.x0, y: source.y0 };
                                        return diagonal({ source: o, target: o });
                                    });

                                    // Transition links to their new position.
                                    link.transition()
                                    .duration(duration)
                                    .attr("d", diagonal);

                                    // Transition exiting nodes to the parent's new position.
                                    link.exit().transition()
                                    .duration(duration)
                                    .attr("d", function (d) {
                                        var o = { x: source.x, y: source.y };
                                        return diagonal({ source: o, target: o });
                                    })
                                    .remove();

                                    // Stash the old positions for transition.
                                    nodes.forEach(function (d) {
                                        d.x0 = d.x;
                                        d.y0 = d.y;
                                    });
                                }

                                // Toggle children on click.
                                function click(d) {
                                    if (d.children) {
                                        d._children = d.children;
                                        d.children = null;
                                    } else {
                                        d.children = d._children;
                                        d._children = null;
                                    }
                                    update(d);
                                }

                                function addNewNode(nodes, id, newNode) {
                                    for( var i = 0; i < nodes.length; i++ ) {
                                        var node = nodes[i];
                                        if( node.id == id ) {
                                            if( !node.children ) node.children = [];
                                            node.children.push( newNode );
                                            return true;
                                        }
                                        if( node.children ) {
                                            if( addNewNode( node.children, id, newNode ) ) {
                                                return true;
                                            }
                                        }
                                    }
                                }

                                // Right-click handler:  Open the selected user story in a new window
                                function rclick(d) {
                                    console.log(root);
                                    console.log(d);
                                    $('.node').contextMenu('context-menu-1', {
                                        'Go to story': {
                                            click: function(element) {
                                                window.open("https://rally1.rallydev.com/#/detail/userstory/" + d.ObjectID);
                                            }
                                        },
                                        'Add': {
                                            click: function(element){
                                                var newNode = {
                                                    name: "Test node",
                                                    depth: d.depth + 1,
                                                    id: ++numStories
                                                }
                                                addNewNode([root], d.id, newNode );
                                                update(root);
                                            }
                                        }
                                    });

                                    d3.event.preventDefault();

                                }
                            }
                        }
                    });
                }
            });
        });
    </script>
</body>
