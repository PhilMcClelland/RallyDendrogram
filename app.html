<head>
    <style>

        .node circle {
            fill: #fff;
            stroke: steelblue;
            stroke-width: 1.5px;
        }

        .node {
            font: 10px sans-serif;
        }

        .link {
            fill: none;
            stroke: #ccc;
            stroke-width: 1.5px;
        }

    </style>
    <script type="text/javascript" src="https://rally1.rallydev.com/apps/2.0p5/sdk-debug.js"></script>
    <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.1/jquery.min.js" type="text/javascript"></script>
</head>
<body>
    <script>

        // Credit for convert to Arun P Johny, http://stackoverflow.com/questions/15376251/hierarchical-json-from-flat-with-parent-id-using-javascript
        function convert(array) {
            var map = {};

            for (var i = 0; i < array.length; i++) {
                var obj = array[i];

                map[obj.FormattedID] = obj;

                var parent = obj.ParentID || '-';
                if (!map[parent]) {
                    map[parent] = {};
                }

                if( map[parent].children === undefined ) map[parent].children = [];
                map[parent].children.push(obj);
            }

            return { name: "D2L", children: map['-'].children };

        }

        Rally.onReady(function () {
            Ext.application({
                name: 'MyApp',
                launch: function () {

                    var storyArray = [];

                    Ext.create('Rally.data.WsapiDataStore', {
                        model: 'UserStory',
                        autoLoad: true,
                        limit: Infinity,
                        fetch: ['Name', 'FormattedID', 'Description', 'Parent', 'ScheduleState'],
                        listeners: {
                            load: function (store, stories) {



                                Ext.Array.each(stories, function (story) {

                                    if (story.get('Parent') !== null && story.get('Parent') !== undefined) {
                                        storyArray.push({ name: story.get('Name'), FormattedID: story.get('FormattedID'), Description: story.get('Description'), ScheduleState: story.get('ScheduleState'), ParentID: story.get('Parent').FormattedID });
                                    }
                                    else {
                                        storyArray.push({ name: story.get('Name'), FormattedID: story.get('FormattedID'), Description: story.get('Description'), ScheduleState: story.get('ScheduleState') });
                                    }
                                });

                                var convertedStoryArray = convert(storyArray);

                                var margin = {top: 20, right: 120, bottom: 20, left: 120},
                                width = 3000 - margin.right - margin.left,
                                height = 2000 - margin.top - margin.bottom;

                                var i = 0,
                                duration = 500,
                                root;

                                var tree = d3.layout.cluster()
                                .size([height, width]);

                                var diagonal = d3.svg.diagonal()
                                .projection(function(d) { return [d.y, d.x]; });

                                var svg = d3.select("body").append("svg")
                                .attr("width", width + margin.right + margin.left)
                                .attr("height", height + margin.top + margin.bottom)
                                .append("g")
                                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

                                root = convertedStoryArray;
                                root.x0 = height / 2;
                                root.y0 = 0;

                                function collapse(d) {
                                    if (d.children) {
                                        d._children = d.children;
                                        d._children.forEach(collapse);
                                        d.children = null;
                                    }
                                }

                                update(root);

                                d3.select(self.frameElement).style("height", "800px");

                                function update(source) {

                                    // Compute the new tree layout.
                                    var nodes = tree.nodes(root).reverse(),
                                    links = tree.links(nodes);

                                    // Update the nodes
                                    var node = svg.selectAll("g.node")
                                    .data(nodes, function(d) { return d.id || (d.id = ++i); });

                                    // Enter any new nodes at the parent's previous position.
                                    var nodeEnter = node.enter().append("g")
                                    .attr("class", "node")
                                    .attr("transform", function(d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
                                    .on("click", click);

                                    nodeEnter.append("circle")
                                    .attr("r", 1e-6)
                                    .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

                                    nodeEnter.append("text")
                                    .attr("x", function(d) { return d.children || d._children ? -10 : 10; })
                                    .attr("dy", ".35em")
                                    .attr("text-anchor", function(d) { return d.children || d._children ? "end" : "start"; })
                                    .text(function(d) { return d.name; })
                                    .style("fill-opacity", 1e-6);

                                    // Transition nodes to their new position.
                                    var nodeUpdate = node.transition()
                                    .duration(duration)
                                    .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });

                                    nodeUpdate.select("circle")
                                    .attr("r", 4.5)
                                    .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

                                    nodeUpdate.select("text")
                                    .style("fill-opacity", 1)
                                    .style("color", "pink");

                                    // Transition exiting nodes to the parent's new position.
                                    var nodeExit = node.exit().transition()
                                    .duration(duration)
                                    .attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })
                                    .remove();

                                    nodeExit.select("circle")
                                    .attr("r", 1e-6);

                                    nodeExit.select("text")
                                    .style("fill-opacity", 1e-6);

                                    // Update the links
                                    var link = svg.selectAll("path.link")
                                    .data(links, function(d) { return d.target.id; });

                                    // Enter any new links at the parent's previous position.
                                    link.enter().insert("path", "g")
                                    .attr("class", "link")
                                    .attr("d", function(d) {
                                        var o = {x: source.x0, y: source.y0};
                                        return diagonal({source: o, target: o});
                                    });

                                    // Transition links to their new position.
                                    link.transition()
                                    .duration(duration)
                                    .attr("d", diagonal);

                                    // Transition exiting nodes to the parent's new position.
                                    link.exit().transition()
                                    .duration(duration)
                                    .attr("d", function(d) {
                                        var o = {x: source.x, y: source.y};
                                        return diagonal({source: o, target: o});
                                    })
                                    .remove();

                                    // Stash the old positions for transition.
                                    nodes.forEach(function(d) {
                                        d.x0 = d.x;
                                        d.y0 = d.y;
                                    });
                                }

                                // Toggle children on click.
                                function click(d) {
                                    if (d.children) {
                                        d._children = d.children;
                                        d.children = null;
                                        } else {
                                        d.children = d._children;
                                        d._children = null;
                                    }
                                    update(d);
                                }
                            }
                        }
                    });
                }
            });
        });
    </script>
</body>
