<head>
    <style>

        .node circle {
            fill: #fff;
            stroke: steelblue;
            stroke-width: 1.5px;
        }

        .node {
            font: 12px sans-serif;
        }

        .node.review { fill: #33CC00; }
        .node.defined { fill: #CC00FF; }
        .node.in-progress { fill: #6600CC; }
        .node.completed { fill: #0033CC; }
        .node.accepted { fill: #FF9999; }
        .node.ready { fill: #CC0000; }

        .link {
            fill: none;
            stroke: #ccc;
            stroke-width: 1.5px;
        }

    </style>
    <script type="text/javascript" src="https://rally1.rallydev.com/apps/2.0p5/sdk-debug.js"></script>
    <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.1/jquery.min.js" type="text/javascript"></script>
</head>
<body>
    <script>

        // Credit for convert to Arun P Johny, http://stackoverflow.com/questions/15376251/hierarchical-json-from-flat-with-parent-id-using-javascript
        function convert(array) {
            var map = {};

            for (var i = 0; i < array.length; i++) {
                var obj = array[i];

                map[obj.FormattedID] = obj;

                var parent = obj.ParentID || '-';
                if (!map[parent]) {
                    map[parent] = {};
                }

                if( map[parent].children === undefined ) map[parent].children = [];
                map[parent].children.push(obj);
            }

            return { name: "D2L", children: map['-'].children };

        }

        Rally.onReady(function () {
            Ext.application({
                name: 'MyApp',
                launch: function () {

                    var storyArray = [];

                    Ext.create('Rally.data.WsapiDataStore', {
                        model: 'UserStory',
                        autoLoad: true,
                        limit: Infinity,
                        fetch: ['Name', 'FormattedID', 'Description', 'Parent', 'ScheduleState', 'ObjectID'],
                        listeners: {
                            load: function (store, stories) {

                                var maxLength = 0; // Length of longest story name (after truncation)
                                var truncateLength = 80; // truncates story names to this number of characters
                                var marginPerCharacter = 5.5; // used to scale the margin in proportion to the number of characters in the name
                                var heightPerStory = 20;

                                Ext.Array.each(stories, function (story) {

                                    var truncatedName = story.get('Name').substring(0, truncateLength);

                                    if (truncatedName.length == truncateLength) { truncatedName = truncatedName + "..."; }

                                    if (story.get('Parent') !== null && story.get('Parent') !== undefined) {
                                        storyArray.push({ name: truncatedName, FormattedID: story.get('FormattedID'), Description: story.get('Description'), ScheduleState: story.get('ScheduleState'), ObjectID: story.get('ObjectID'), ParentID: story.get('Parent').FormattedID });
                                    }
                                    else {
                                        storyArray.push({ name: truncatedName, FormattedID: story.get('FormattedID'), Description: story.get('Description'), ScheduleState: story.get('ScheduleState'), ObjectID: story.get('ObjectID') });
                                    }

                                    if (truncatedName.length > maxLength) {
                                        maxLength = truncatedName.length;
                                    }

                                    console.log(maxLength);

                                });

                                function decode(str) {
                                    return $("<div/>").html(str).text();
                                }

                                $.each(storyArray, function (i, s) {
                                    s.name = decode(s.name);
                                    s.Description = decode(s.Description);
                                });

                                var convertedStoryArray = convert(storyArray);

                                var margin = { top: 20, right: marginPerCharacter * maxLength, bottom: 20, left: 120 },
                                width = 3000 - margin.right - margin.left,
                                height = (storyArray.length * heightPerStory) - margin.top - margin.bottom;

                                var i = 0,
                                duration = 500,
                                root;

                                var tree = d3.layout.cluster()
                                .size([height, width]);

                                var diagonal = d3.svg.diagonal()
                                .projection(function (d) { return [d.y, d.x]; });

                                var svg = d3.select("body").append("svg")
                                .attr("width", width + margin.right + margin.left)
                                .attr("height", height + margin.top + margin.bottom)
                                .append("g")
                                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

                                root = convertedStoryArray;
                                root.x0 = height / 2;
                                root.y0 = 0;

                                function collapse(d) {
                                    if (d.children) {
                                        d._children = d.children;
                                        d._children.forEach(collapse);
                                        d.children = null;
                                    }
                                }

                                update(root);

                                d3.select(self.frameElement).style("height", "800px");

                                function update(source) {

                                    // Compute the new tree layout.
                                    var nodes = tree.nodes(root).reverse(),
                                    links = tree.links(nodes);

                                    // Update the nodes
                                    var node = svg.selectAll("g.node")
                                    .data(nodes, function (d) { return d.id || (d.id = ++i); });

                                    // Enter any new nodes at the parent's previous position.
                                    var nodeEnter = node.enter().append("g")
                                    .attr("class", function (d) {
                                        classString = "node";
                                        switch (d.ScheduleState) {
                                            case "In Review":
                                                classString += " review";
                                                break;
                                            case "Defined":
                                                classString += " defined";
                                                break;
                                            case "In-Progress":
                                                classString += " in-progress";
                                                break;
                                            case "Completed":
                                                classString += " completed";
                                                break;
                                            case "Accepted":
                                                classString += " accepted";
                                                break;
                                            case "Ready for Release":
                                                classString += " ready";
                                                break;
                                            default: break;
                                        }
                                        return classString;
                                    })
                                    .attr("transform", function (d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
                                    .on("click", click)
                                    .on("contextmenu", rclick);

                                    nodeEnter.append("circle")
                                    .attr("r", 1e-6)
                                    .style("fill", function (d) { return d._children ? "lightsteelblue" : "#fff"; });

                                    nodeEnter.append("text")
                                    .attr("x", function (d) { return d.children || d._children ? -10 : 10; })
                                    .attr("dy", ".35em")
                                    .attr("text-anchor", function (d) { return d.children || d._children ? "end" : "start"; })
                                    .text(function (d) { return d.name; })
                                    .style("fill-opacity", 1e-6);

                                    // Transition nodes to their new position.
                                    var nodeUpdate = node.transition()
                                    .duration(duration)
                                    .attr("transform", function (d) { return "translate(" + d.y + "," + d.x + ")"; });

                                    nodeUpdate.select("circle")
                                    .attr("r", 4.5)
                                    .style("fill", function (d) { return d._children ? "lightsteelblue" : "#fff"; });

                                    nodeUpdate.select("text")
                                    .attr("x", function (d) { return d.children ? -10 : 10; })
                                    .attr("text-anchor", function (d) { return d.children ? "end" : "start"; })
                                    .style("fill-opacity", 1);

                                    // Transition exiting nodes to the parent's new position.
                                    var nodeExit = node.exit().transition()
                                    .duration(duration)
                                    .attr("transform", function (d) { return "translate(" + source.y + "," + source.x + ")"; })
                                    .remove();

                                    nodeExit.select("circle")
                                    .attr("r", 1e-6);

                                    nodeExit.select("text")
                                    .style("fill-opacity", 1e-6);

                                    // Update the links
                                    var link = svg.selectAll("path.link")
                                    .data(links, function (d) { return d.target.id; });

                                    // Enter any new links at the parent's previous position.
                                    link.enter().insert("path", "g")
                                    .attr("class", "link")
                                    .attr("d", function (d) {
                                        var o = { x: source.x0, y: source.y0 };
                                        return diagonal({ source: o, target: o });
                                    });

                                    // Transition links to their new position.
                                    link.transition()
                                    .duration(duration)
                                    .attr("d", diagonal);

                                    // Transition exiting nodes to the parent's new position.
                                    link.exit().transition()
                                    .duration(duration)
                                    .attr("d", function (d) {
                                        var o = { x: source.x, y: source.y };
                                        return diagonal({ source: o, target: o });
                                    })
                                    .remove();

                                    // Stash the old positions for transition.
                                    nodes.forEach(function (d) {
                                        d.x0 = d.x;
                                        d.y0 = d.y;
                                    });
                                }

                                // Toggle children on click.
                                function click(d) {


                                    if (d.children) {
                                        d._children = d.children;
                                        d.children = null;
                                    } else {
                                        d.children = d._children;
                                        d._children = null;
                                    }
                                    update(d);
                                }

                                // Right-click handler:  Open the selected user story in a new window
                                function rclick(d) {

                                    window.open("https://rally1.rallydev.com/#/detail/userstory/" + d.ObjectID);

                                    d3.event.preventDefault();

                                }
                            }
                        }
                    });
                }
            });
        });
    </script>
</body>
